### A Pluto.jl notebook ###
# v0.19.26

using Markdown
using InteractiveUtils

# ╔═╡ d60f02ce-0a83-4edb-9747-b3de9ba1ae2b
using Markdown

# ╔═╡ 5dfaa4bb-f544-43df-a390-a9e326784fed
using InteractiveUtils

# ╔═╡ 7ea81498-700d-4402-bea4-37b5203d088f
using Logging

# ╔═╡ 5b0505f0-ab35-4ebc-9458-1914a54c7bfa
md"""
### Mini rapport: Phase 2 du projet
"""

# ╔═╡ 56c69abe-5f9d-433d-87ee-ad4d14d7e4ac
md""" Le  code se trouve au lien suivant: """

# ╔═╡ c49caeea-0bdd-4cd3-8e50-c739befecd98
md"""[https://github.com/MohamedLaghdafHABIBOULLAH/mth6412b-starter-code.git](https://github.com/MohamedLaghdafHABIBOULLAH/mth6412b-starter-code.git)"""

# ╔═╡ 2ca058c6-5f4b-47d1-9282-a8803eaf19c5
md""" Le lecteur peut fork le projet et lancer le fichier phase2/main.jl pour retrouver les résultats ci-dessous"""

# ╔═╡ d16af9e4-e9fd-49df-97e4-b6af7193d63f
md"""
##### 1. Choisir et implémenter une structure de données pour les composantes connexes d’un graphe 
"""

# ╔═╡ 5b9924f3-f260-40be-8144-53d4fd3e0645
""" Implémenter Preds dont la composante est un dictionnaire qui contient le parent ou predecesseur de chaque noeud."""
mutable struct Preds
    parent::Dict{String, String}
    Rank::Dict{String, Int} # cet attribut sera utile pour les heuristiques
end

# ╔═╡ 905d4a8a-9d15-45b3-8e3a-ffb33cd835b3
md"""
```julia
mutable struct Preds
    parent::Dict{String, String}
    Rank::Dict{String, Int}
end
```
"""

# ╔═╡ 3c45416e-9c54-48fe-9e63-edcb49afd27c
md"""
###### Constructeur à partir d'une liste de noeuds on crée une structure Preds où chaque noeud est le parent de lui-même """

# ╔═╡ d670b6ea-a115-4a5a-bf9e-0179b05fb447
md"""
```julia
function Preds(nodes::Vector{Node{T}}) where T
    parent = Dict{String, String}()
    Rank = Dict{String, Int}()
    for node in nodes
        parent[node.name] = node.name
        Rank[node.name] = 0
    end
    Preds(parent, Rank)
end
```
"""

# ╔═╡ 30df8065-0dec-4125-837c-4e12b63cd188
md"""
##### 2. Implémenter l’algorithme de Kruskal vu au laboratoire et le tester sur l’exemple des notes de cours ;.
"""


# ╔═╡ 6b0d03bb-47fb-4964-a205-9212a3b3e0a8
md"""
###### On commence par des fonctions qui vont nous aider à retrouver le prent et à réunir deux enfants au même parent """

# ╔═╡ 1116fc1c-5012-429e-a922-3d71fb8cff1d
""" Fonction find pour trouver le parent (représentant) d'un nœud"""
function find(pred::Preds, node_name)
    if pred.parent[node_name] != node_name
        pred.parent[node_name] = find(pred, pred.parent[node_name])
    end
    return pred.parent[node_name]
end

# ╔═╡ 99da20b1-de32-4c69-88a7-bb2e9fbbc787
md"""
```julia
function find(pred::Preds, node_name)
    if pred.parent[node_name] != node_name
        pred.parent[node_name] = find(pred, pred.parent[node_name])
    end
    return pred.parent[node_name]
end
```
"""

# ╔═╡ 21bcf9a6-6a3e-441e-8ba0-389d7524d647
""" Fonction union pour fusionner les composantes connexes des 2 noeuds (dire qu'ils ont le même parent) """
function union(pred::Preds, node1_name, node2_name)
    root1 = find(pred, node1_name)
    root2 = find(pred, node2_name)
    if root1 != root2
        pred.parent[root1] = root2
    end
end

# ╔═╡ 99ae39f7-ab7c-4516-9c76-1992eab8c356
md"""
```julia
function union(pred::Preds, node1_name, node2_name)
    root1 = find(pred, node1_name)
    root2 = find(pred, node2_name)
    if root1 != root2
        pred.parent[root1] = root2
    end
end
```
"""

# ╔═╡ 745a99fb-4d60-4b47-8bcf-2625063e44d8
md"""
```julia
# Implémenter Kruskal pour le minimum_spanning_tree
function kruskal(graph::Graph; heuristique::Symbol = :default)
    edges = sort(graph.edges, by = x -> x.weight)
    minimum_spanning_tree = Edge{typeof(graph.nodes[1].data)}[]
    pred = Preds(graph.nodes)
    total_weight = 0.
    for edge in edges
        if find(pred, edge.node1.name) != find(pred, edge.node2.name) # si les noeuds font partie de composante connexe distincte
            push!(minimum_spanning_tree, edge)
            (heuristique == :default) && union(pred, edge.node1.name, edge.node2.name)
            total_weight += edge.weight
        end
    end
    return minimum_spanning_tree, total_weight
end
```
"""

# ╔═╡ d59015cb-e1f7-4f9e-9a21-180eff8e4b77
md"""
##### 3. Répondre à la question concernant le rang 
"""

# ╔═╡ 790f95ac-38f5-4546-8503-8a969aa33918
md"""
###### a. Montrer que le rang d’un nœud sera toujours inférieur à |S | − 1. Montrer ensuite que ce rang sera en fait toujours inférieur à ⌊log2(|S|)⌋;
"""

# ╔═╡ 53452089-7f8a-4fc1-871b-1313e866436f
md""" On sait qu'au pire des cas on aura une liste chainée du premier parent au dernier noeud et puisque le rang incrémente de 1 lors de l'ajout d'un noeud au pire des cas alors rang(s) inférieur à |S | − 1 pour tout noeud s.
"""

# ╔═╡ b1d5add3-ac8d-402c-902e-8567891374aa
md""" D'autre part, pour incrémenter le rang dans les pires des cas, on aura à fusionner deus enselbles de noeuds de même nombre donc on a 2^(rang(s)) < |S , d'où le résultat.
"""

# ╔═╡ 723b6ebd-36be-4ea0-9669-ea9250592d78
md"""
##### 4. Implémenter l’algorithme de Prim vu au laboratoire et le tester sur l’exemple des notes de cours.
"""

# ╔═╡ 08300d8f-c079-4a2e-a102-b70f567f439c
md"""
```julia
# Fonction pour implémenter l'algorithme de Prim afin de trouver l'arbre couvrant minimum
function prim(graph::Graph{T}) where T
    nodes = graph.nodes
    num_nodes = length(nodes)
    
    # Initialiser un ensemble pour suivre les nœuds sélectionnés
    selected = Set{Node{T}}()
    
    # Initialiser une file de priorité pour les arêtes candidates
    candidate_edges = PriorityQueue{Edge{T}}()
    
    # Sélectionner le premier nœud arbitrairement et ajouter ses arêtes aux arêtes candidates
    push!(selected, nodes[1])
    for edge in graph.edges
        if edge.node1 in selected && edge.node2 ∉ selected || edge.node1 ∉ selected && edge.node2 in selected
            push!(candidate_edges, edge)
        end
    end
    
    # Initialiser le résultat
    mst_edges = Edge{T}[]
    total_weight = 0
    
    # Exécuter l'algorithme de Prim
    while length(selected) < num_nodes
        # Trouver l'arête de poids minimum dans les arêtes candidates
        min_edge = popfirst!(candidate_edges)
        min_weight = min_edge.weight
        
        # Vérifier si l'ajout de l'arête forme un cycle ou connecte un nouveau nœud
        if !(min_edge.node1 in selected && min_edge.node2 in selected)
            push!(mst_edges, min_edge)
            total_weight += min_weight
            
            # Ajouter le nouveau nœud à l'ensemble sélectionné
            new_node = min_edge.node1 in selected ? min_edge.node2 : min_edge.node1
            push!(selected, new_node)
            
            # Ajouter les arêtes du nouveau nœud aux arêtes candidates
            for edge in graph.edges
                if (edge.node1 in selected && edge.node2 ∉ selected) || (edge.node1 ∉ selected && edge.node2 in selected)
                    push!(candidate_edges, edge)
                end
            end
        end
    end
    
    return mst_edges, total_weight
end
```
"""

# ╔═╡ 613362b9-ce0d-4d74-a1e3-8e88a0859249
md"""
##### 5. Accompagner votre code de tests unitaires ;

"""

# ╔═╡ 31731546-f972-4e36-8508-623ab6ff257e
md"""
###### Grace au package Test, on fait les tests suivants su l'exemple du cours:

"""

# ╔═╡ e4f5b0ae-773a-4dae-ab00-78e5715195e4
md"""
```julia
# Exemple d'utilisation
node1 = Node("A", 1)
node2 = Node("B", 2)
node3 = Node("C", 3)
node4 = Node("D", 4)
node5 = Node("E", 4)
node6 = Node("F", 4)
node7 = Node("G", 4)
node8 = Node("H", 4)
node9 = Node("I", 4)

edge1 = Edge("AB", node1, node2, 4)
edge2 = Edge("BC", node2, node3, 8)
edge3 = Edge("CD", node3, node4, 7)
edge4 = Edge("DE", node4, node5, 9)
edge5 = Edge("EF", node5, node6, 10)
edge6 = Edge("FC", node6, node3, 4)
edge7 = Edge("FG", node6, node7, 2)
edge8 = Edge("GI", node9, node7, 6)
edge9 = Edge("HG", node8, node7, 1)
edge10 = Edge("HI", node8, node9, 7)
edge11 = Edge("HA", node8, node1, 8)
edge12 = Edge("HB", node8, node2, 11)
edge13 = Edge("DF", node6, node4, 14)
edge14 = Edge("IC", node9, node3, 2)

nodes_g = [node1, node2, node3, node4, node5, node6, node7, node8, node9]
edges_g = [edge1, edge2, edge3, edge4, edge5, edge6, edge7, edge8, edge9, edge10, edge11, edge12, edge13, edge14]

graph_g = Graph("Test Graph", nodes_g, edges_g)
```
"""

# ╔═╡ 22ac3ee9-240c-4ce4-b715-f39d2cfa3d19
md"""
```julia
using Test
# Définissez des tests unitaires pour les structures
@testset "Node, Edge, and Graph Tests" begin
    @test node1.name == "A"
    @test node1.data == 1
    @test typeof(node1.data) == Int64
    
    @test edge1.name == "AB"
    @test edge1.node1 == node1
    @test edge1.node2 == node2
    @test edge1.weight == 4
    @test typeof(edge1.weight) == Int64
    
    @test graph_g.name == "Test Graph"
    @test graph_g.nodes == nodes_g
    @test graph_g.edges == edges_g
    @test typeof(graph_g.name) == String

	mst_prim, total_weight_prim = prim(graph_g)
    mst_kruuskal, total_weight_kruskal = kruskal(graph_g)
    @test total_weight_prim == total_weight_kruskal
    @test total_weight_prim == 37 # Le total_weight de la solution de l'exemple du cours
end

```
"""

# ╔═╡ 37a77e33-d9ce-48b4-9934-ad41c84a0a6e
md"""
```julia
Test Summary:               | Pass  Total  Time
Node, Edge, and Graph Tests |   14     14  0.0s
Test.DefaultTestSet("Node, Edge, and Graph Tests", Any[], 14, false, false, true, 1.699310453113274e9, 1.699310453116649e9)
```
"""

# ╔═╡ 00000000-0000-0000-0000-000000000001
PLUTO_PROJECT_TOML_CONTENTS = """
[deps]
InteractiveUtils = "b77e0a4c-d291-57a0-90e8-8db25a27a240"
Logging = "56ddb016-857b-54e1-b83d-db4d58db5568"
Markdown = "d6f4376e-aef5-505a-96c1-9c027394607a"
"""

# ╔═╡ 00000000-0000-0000-0000-000000000002
PLUTO_MANIFEST_TOML_CONTENTS = """
# This file is machine-generated - editing it directly is not advised

julia_version = "1.8.3"
manifest_format = "2.0"
project_hash = "348ed7e828d2091a44e211d4df367eb5f2d0eb19"

[[deps.Base64]]
uuid = "2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"

[[deps.InteractiveUtils]]
deps = ["Markdown"]
uuid = "b77e0a4c-d291-57a0-90e8-8db25a27a240"

[[deps.Logging]]
uuid = "56ddb016-857b-54e1-b83d-db4d58db5568"

[[deps.Markdown]]
deps = ["Base64"]
uuid = "d6f4376e-aef5-505a-96c1-9c027394607a"
"""

# ╔═╡ Cell order:
# ╠═d60f02ce-0a83-4edb-9747-b3de9ba1ae2b
# ╠═5dfaa4bb-f544-43df-a390-a9e326784fed
# ╠═7ea81498-700d-4402-bea4-37b5203d088f
# ╟─5b0505f0-ab35-4ebc-9458-1914a54c7bfa
# ╟─56c69abe-5f9d-433d-87ee-ad4d14d7e4ac
# ╟─c49caeea-0bdd-4cd3-8e50-c739befecd98
# ╟─2ca058c6-5f4b-47d1-9282-a8803eaf19c5
# ╟─d16af9e4-e9fd-49df-97e4-b6af7193d63f
# ╟─5b9924f3-f260-40be-8144-53d4fd3e0645
# ╟─905d4a8a-9d15-45b3-8e3a-ffb33cd835b3
# ╟─3c45416e-9c54-48fe-9e63-edcb49afd27c
# ╟─d670b6ea-a115-4a5a-bf9e-0179b05fb447
# ╟─30df8065-0dec-4125-837c-4e12b63cd188
# ╟─6b0d03bb-47fb-4964-a205-9212a3b3e0a8
# ╟─1116fc1c-5012-429e-a922-3d71fb8cff1d
# ╟─99da20b1-de32-4c69-88a7-bb2e9fbbc787
# ╟─21bcf9a6-6a3e-441e-8ba0-389d7524d647
# ╟─99ae39f7-ab7c-4516-9c76-1992eab8c356
# ╟─745a99fb-4d60-4b47-8bcf-2625063e44d8
# ╟─d59015cb-e1f7-4f9e-9a21-180eff8e4b77
# ╟─790f95ac-38f5-4546-8503-8a969aa33918
# ╟─53452089-7f8a-4fc1-871b-1313e866436f
# ╟─b1d5add3-ac8d-402c-902e-8567891374aa
# ╟─723b6ebd-36be-4ea0-9669-ea9250592d78
# ╟─08300d8f-c079-4a2e-a102-b70f567f439c
# ╟─613362b9-ce0d-4d74-a1e3-8e88a0859249
# ╟─31731546-f972-4e36-8508-623ab6ff257e
# ╟─e4f5b0ae-773a-4dae-ab00-78e5715195e4
# ╟─22ac3ee9-240c-4ce4-b715-f39d2cfa3d19
# ╟─37a77e33-d9ce-48b4-9934-ad41c84a0a6e
# ╟─00000000-0000-0000-0000-000000000001
# ╟─00000000-0000-0000-0000-000000000002
